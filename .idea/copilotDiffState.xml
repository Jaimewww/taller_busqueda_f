<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/util/CsvReader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/util/CsvReader.java" />
              <option name="originalContent" value="package util;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVRecord;&#10;import structures.SimpleList;&#10;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class CsvReader {&#10;&#10;    // Lee una columna especifica de un archivo CSV y la convierte en un arreglo de Integer.&#10;    public static Integer[] readIntegerColumn(String filePath, String columnName) throws IOException {&#10;        // Configuracion del formato CSV&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        // Lista para almacenar los valores Integer&#10;        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;&#10;                // Reemplazar comas por puntos y eliminar espacios&#10;                String cleanedValue = value.replace(',', '.').trim();&#10;&#10;                if (!cleanedValue.isEmpty()) {&#10;                    try {&#10;                        Integer integerValue = Integer.parseInt(cleanedValue);&#10;                        integerList.add(integerValue);&#10;                    } catch (NumberFormatException e) {&#10;                        System.err.println(&quot;Ignorando valor inválido: '&quot; + value + &quot;'&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return integerList.toArray(new Integer[0]);&#10;    }&#10;&#10;    public static SimpleList&lt;Integer&gt; readIntegerColumnList(String filePath, String columnName) throws IOException {&#10;        // Configuracion del formato CSV (mismo formato que el metodo original)&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;        SimpleList&lt;Integer&gt; integerList = new SimpleList&lt;&gt;();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;&#10;                // Reemplazar comas por puntos y eliminar espacios&#10;                String cleanedValue = value.replace(',', '.').trim();&#10;&#10;                if (!cleanedValue.isEmpty()) {&#10;                    try {&#10;                        Integer integerValue = Integer.parseInt(cleanedValue);&#10;                        integerList.pushBack(integerValue);&#10;&#10;                    } catch (NumberFormatException e) {&#10;                        System.err.println(&quot;Ignorando valor inválido: '&quot; + value + &quot;'&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return integerList; // Retorna la lista enlazada simple.&#10;    }&#10;&#10;    // Devuelve un arreglo con los nombres de las cabeceras (headers) del CSV.&#10;    public static String[] getHeaders(String filePath) throws IOException {&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;            return csvParser.getHeaderMap().keySet().toArray(new String[0]);&#10;        }&#10;    }&#10;&#10;    // Lee hasta `limit` valores (no vacíos) de la columna especificada y los devuelve como strings.&#10;    public static String[] readSampleValues(String filePath, String columnName, int limit) throws IOException {&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        List&lt;String&gt; samples = new ArrayList&lt;&gt;();&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;                if (value == null) continue;&#10;                String v = value.trim();&#10;                if (!v.isEmpty()) {&#10;                    samples.add(v);&#10;                    if (samples.size() &gt;= limit) break;&#10;                }&#10;            }&#10;        }&#10;&#10;        return samples.toArray(new String[0]);&#10;    }&#10;}" />
              <option name="updatedContent" value="package util;&#10;&#10;import org.apache.commons.csv.CSVFormat;&#10;import org.apache.commons.csv.CSVParser;&#10;import org.apache.commons.csv.CSVRecord;&#10;import structures.SimpleList;&#10;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.io.Reader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class CsvReader {&#10;&#10;    // Lee una columna especifica de un archivo CSV y la convierte en un arreglo de Integer.&#10;    public static Integer[] readIntegerColumn(String filePath, String columnName) throws IOException {&#10;        // Configuracion del formato CSV&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        // Lista para almacenar los valores Integer&#10;        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;&#10;                // Reemplazar comas por puntos y eliminar espacios&#10;                String cleanedValue = value.replace(',', '.').trim();&#10;&#10;                if (!cleanedValue.isEmpty()) {&#10;                    try {&#10;                        Integer integerValue = Integer.parseInt(cleanedValue);&#10;                        integerList.add(integerValue);&#10;                    } catch (NumberFormatException e) {&#10;                        System.err.println(&quot;Ignorando valor inválido: '&quot; + value + &quot;'&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return integerList.toArray(new Integer[0]);&#10;    }&#10;&#10;    public static SimpleList&lt;Integer&gt; readIntegerColumnList(String filePath, String columnName) throws IOException {&#10;        // Configuracion del formato CSV (mismo formato que el metodo original)&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;        SimpleList&lt;Integer&gt; integerList = new SimpleList&lt;&gt;();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;&#10;                // Reemplazar comas por puntos y eliminar espacios&#10;                String cleanedValue = value.replace(',', '.').trim();&#10;&#10;                if (!cleanedValue.isEmpty()) {&#10;                    try {&#10;                        Integer integerValue = Integer.parseInt(cleanedValue);&#10;                        integerList.pushBack(integerValue);&#10;&#10;                    } catch (NumberFormatException e) {&#10;                        System.err.println(&quot;Ignorando valor inválido: '&quot; + value + &quot;'&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return integerList; // Retorna la lista enlazada simple.&#10;    }&#10;&#10;    // Devuelve un arreglo con los nombres de las cabeceras (headers) del CSV.&#10;    public static String[] getHeaders(String filePath) throws IOException {&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;            return csvParser.getHeaderMap().keySet().toArray(new String[0]);&#10;        }&#10;    }&#10;&#10;    // Lee hasta `limit` valores (no vacíos) de la columna especificada y los devuelve como strings.&#10;    public static String[] readSampleValues(String filePath, String columnName, int limit) throws IOException {&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        List&lt;String&gt; samples = new ArrayList&lt;&gt;();&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                String value = csvRecord.get(columnName);&#10;                if (value == null) continue;&#10;                String v = value.trim();&#10;                if (!v.isEmpty()) {&#10;                    samples.add(v);&#10;                    if (samples.size() &gt;= limit) break;&#10;                }&#10;            }&#10;        }&#10;&#10;        return samples.toArray(new String[0]);&#10;    }&#10;&#10;    // Devuelve únicamente los headers cuya columna contiene valores Integer.&#10;    // Recorre el archivo y marca como válidas las columnas que tienen al menos&#10;    // un valor entero y no presentan valores no numéricos (entre los registros).&#10;    public static String[] getNumericHeaders(String filePath) throws IOException {&#10;        CSVFormat csvFormat = CSVFormat.DEFAULT.builder()&#10;                .setHeader()&#10;                .setSkipHeaderRecord(true)&#10;                .setIgnoreSurroundingSpaces(true)&#10;                .setDelimiter(';')&#10;                .build();&#10;&#10;        try (Reader reader = new FileReader(filePath);&#10;             CSVParser csvParser = new CSVParser(reader, csvFormat)) {&#10;&#10;            // Obtener headers&#10;            List&lt;String&gt; headers = new ArrayList&lt;&gt;(csvParser.getHeaderMap().keySet());&#10;            int n = headers.size();&#10;            boolean[] ok = new boolean[n];&#10;            boolean[] seenNumeric = new boolean[n];&#10;            for (int i = 0; i &lt; n; i++) ok[i] = true;&#10;&#10;            for (CSVRecord csvRecord : csvParser) {&#10;                for (int i = 0; i &lt; n; i++) {&#10;                    if (!ok[i]) continue; // ya descartada&#10;                    String h = headers.get(i);&#10;                    String value = csvRecord.get(h);&#10;                    if (value == null) continue;&#10;                    String v = value.replace(',', '.').trim();&#10;                    if (v.isEmpty()) continue;&#10;                    try {&#10;                        Integer.parseInt(v);&#10;                        seenNumeric[i] = true;&#10;                    } catch (NumberFormatException e) {&#10;                        // valor no numérico: descartar header&#10;                        ok[i] = false;&#10;                    }&#10;                }&#10;            }&#10;&#10;            List&lt;String&gt; numeric = new ArrayList&lt;&gt;();&#10;            for (int i = 0; i &lt; n; i++) if (ok[i] &amp;&amp; seenNumeric[i]) numeric.add(headers.get(i));&#10;            return numeric.toArray(new String[0]);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/util/SearchResult.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/util/SearchResult.java" />
              <option name="originalContent" value="package util;&#10;&#10;/**&#10; * Clase para almacenar el resultado de una busqueda en un arreglo&#10; * @author Jaime Landazuri&#10; */&#10;&#10;public class SearchResult {&#10;    private int index;&#10;    private int value;&#10;&#10;    public SearchResult(int index, int value) {&#10;        this.index = index;&#10;        this.value = value;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;{Index: &quot; + index + &quot;, Value: &quot; + value + &quot;}&quot;;&#10;    }&#10;}" />
              <option name="updatedContent" value="package util;&#10;&#10;/**&#10; * Clase para almacenar el resultado de una busqueda en un arreglo&#10; * @author Jaime Landazuri&#10; */&#10;&#10;public class SearchResult {&#10;    private int index;&#10;    private int value;&#10;&#10;    public SearchResult(int index, int value) {&#10;        this.index = index;&#10;        this.value = value;&#10;    }&#10;&#10;    public int getIndex() {&#10;        return index;&#10;    }&#10;&#10;    public int getValue() {&#10;        return value;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;{Index: &quot; + index + &quot;, Value: &quot; + value + &quot;}&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>